# Dynamic Programming

An explanation from ChatGPT. Alright, imagine you have a big puzzle to solve,
but it's too big for you to finish in one go. So, you decide to break it into
smaller puzzles, and you solve each of these small puzzles one by one. But,
here's the clever part: as you solve these small puzzles, you remember the
solutions. That way, if you come across the same small puzzle again, you don't
have to solve it all over again. You already know the answer! Dynamic
programming is like solving a big puzzle by breaking it into smaller ones and
remembering the solutions to the smaller ones to make solving the big puzzle
easier and faster.

## Policy Evaluation (Prediction)

```{pseudocode}
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true

\begin{algorithm}
\caption{Quicksort}
\begin{algorithmic}
\Procedure{Quicksort}{$A, p, r$}
  \If{$p < r$}
    \State $q = $ \Call{Partition}{$A, p, r$}
    \State \Call{Quicksort}{$A, p, q - 1$}
    \State \Call{Quicksort}{$A, q + 1, r$}
  \EndIf
\EndProcedure
\Procedure{Partition}{$A, p, r$}
  \State $x = A[r]$
  \State $i = p - 1$
  \For{$j = p$ \To $r - 1$}
    \If{$A[j] < x$}
      \State $i = i + 1$
      \State exchange
      $A[i]$ with     $A[j]$
    \EndIf
    \State exchange $A[i]$ with $A[r]$
  \EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}
```

## Policy Improvement

## Policy Iteration

## Value Iteration

## Asynchronous Dynamic Programming

## Generalized Policy Iteration

## Efficiency of Dynamic Programming

## Summary

[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "From Markov Decision Processes to Reinforcement Learning with Python",
    "section": "",
    "text": "Preface\nThis notes are based in the course from Berstekas for the MIT see all lectures and other resources for complete the understanding.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#abstract",
    "href": "index.html#abstract",
    "title": "From Markov Decision Processes to Reinforcement Learning with Python",
    "section": "Abstract",
    "text": "Abstract\nWe present an introduction to the solution of multi-stage optimization problems. Starting from the dynamic programming algorithm, we consider theoretical and computational aspects, mainly of deterministic problems, and discuss how to generalize some of the results to Markovian decision processes.\nThe classic problem with which the essential ideas of dynamic programming can be introduced is the optimal route problem (shortest route considering distances, or cheapest route considering costs) (Bertsekas 2005; Brandimarte 2013). A simple version of this problem is shown schematically in Fig 1. By exhaustion, we deploy the cost of path in Table 1.\n\n\n\n\n\n\nFigure 1: The shortest path\n\n\n\nIn this problem, the optimal route to go from the node labeled \\(0\\) to the node labeled \\(7\\) is to be determined. The costs between each pair of nodes connected by an arrow are represented by a number next to it. For example, the cost to go from node 0 to node 2 is 6. The optimal route will be the one for which the sum of their costs is minimum. This optimal route can be obtained by an exhaustive enumeration; generating all possible routes from node \\(0\\) to node \\(7\\) and choosing the minimum cost route.\n\n\n\nTable 1: The shortest path by exhaustion see (Brandimarte 2013).\n\n\n\n\n\nPath\nCost\n\n\n\n\n\\(0 \\to 1 \\to 4 \\to 7\\)\n18\n\n\n\\(0 \\to 1 \\to 3 \\to 4 \\to 7\\)\n22\n\n\n\\(0 \\to 1 \\to 3 \\to 6 \\to 7\\)\n18\n\n\n\\(0 \\to 1 \\to 3 \\to 5 \\to 6 \\to 7\\)\n20\n\n\n\\(\\mathbf{0 \\to 1 \\to 3 \\to 5 \\to 7}\\)\n16\n\n\n\\(0 \\to 2 \\to 3 \\to 4 \\to 7\\)\n23\n\n\n\\(0 \\to 2 \\to 3 \\to 6 \\to 7\\)\n19\n\n\n\\(0 \\to 2 \\to 3 \\to 5 \\to 6 \\to 7\\)\n21\n\n\n\\(0 \\to 2 \\to 3 \\to 5 \\to 7\\)\n17\n\n\n\\(0 \\to 2 \\to 5 \\to 6 \\to 7\\)\n22\n\n\n\\(0 \\to 2 \\to 5 \\to 7\\)\n18\n\n\n\n\n\n\nThe optimal path is \\[\n  0 \\to   1 \\to 3 \\to 5 \\to  7,\n\\] with cost 16.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "01-introduction/general_intro.html",
    "href": "01-introduction/general_intro.html",
    "title": "Abstract",
    "section": "",
    "text": "We present an introduction to the solution of multi-stage optimization problems. Starting from the dynamic programming algorithm, we consider theoretical and computational aspects, mainly of deterministic problems, and discuss how to generalize some of the results to Markovian decision processes.\nThe classic problem with which the essential ideas of dynamic programming can be introduced is the optimal route problem (shortest route considering distances, or cheapest route considering costs) (Bertsekas 2005; Brandimarte 2013). A simple version of this problem is shown schematically in Fig fig-brandimarte_net. By exhaustion, we deploy the cost of path in Table tbl-brandimarte_paths.\n\n\n\n\n\n\nFigure 1: The shortest path\n\n\n\nIn this problem, the optimal route to go from the node labeled \\(0\\) to the node labeled \\(7\\) is to be determined. The costs between each pair of nodes connected by an arrow are represented by a number next to it. For example, the cost to go from node 0 to node 2 is 6. The optimal route will be the one for which the sum of their costs is minimum. This optimal route can be obtained by an exhaustive enumeration; generating all possible routes from node \\(0\\) to node \\(7\\) and choosing the minimum cost route.\n\n\n\nTable 1: The shortest path by exhaustion see (Brandimarte 2013).\n\n\n\n\n\nPath\nCost\n\n\n\n\n\\(0 \\to 1 \\to 4 \\to 7\\)\n18\n\n\n\\(0 \\to 1 \\to 3 \\to 4 \\to 7\\)\n22\n\n\n\\(0 \\to 1 \\to 3 \\to 6 \\to 7\\)\n18\n\n\n\\(0 \\to 1 \\to 3 \\to 5 \\to 6 \\to 7\\)\n20\n\n\n\\(\\mathbf{0 \\to 1 \\to 3 \\to 5 \\to 7}\\)\n16\n\n\n\\(0 \\to 2 \\to 3 \\to 4 \\to 7\\)\n23\n\n\n\\(0 \\to 2 \\to 3 \\to 6 \\to 7\\)\n19\n\n\n\\(0 \\to 2 \\to 3 \\to 5 \\to 6 \\to 7\\)\n21\n\n\n\\(0 \\to 2 \\to 3 \\to 5 \\to 7\\)\n17\n\n\n\\(0 \\to 2 \\to 5 \\to 6 \\to 7\\)\n22\n\n\n\\(0 \\to 2 \\to 5 \\to 7\\)\n18\n\n\n\n\n\n\nThe optimal path is \\[\n  0 \\to   1 \\to 3 \\to 5 \\to  7,\n\\] with cost 16.\n\n\n\n\n\nFigure 1: The shortest path\n\n\n\nBertsekas, Dimitri P. 2005. Dynamic Programming and Optimal Control. Vol. I. Third. Athena Scientific, Belmont, MA.\n\n\nBrandimarte, Paolo. 2013. Numerical Methods in Finance and Economics: A MATLAB-Based Introduction. 2nd ed. Hoboken, New Jersey: John Wiley & Sons.",
    "crumbs": [
      "Abstract"
    ]
  },
  {
    "objectID": "02-introductionToRL/intro.html",
    "href": "02-introductionToRL/intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Trial-Error\nAccording to Richard S. Sutton and Andrew G. Barto Sutton and Barto (2018)–the first authors to use the term–Reinforced Learning Reinforcement learning is about what to do, that is, how to map situations to action so that we optimize a reward. The learner must discover which action yield the best reward by trying them. In the most general sense, action may not only affect immediate reward but also the next situation and, through that, all subsequent rewards.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "02-introductionToRL/intro.html#trial-error",
    "href": "02-introductionToRL/intro.html#trial-error",
    "title": "Introduction",
    "section": "",
    "text": "Sensation action and goal\nAt the same time, Reinforcement Learning encloses a problem, a class of solution methods, and the field that studies this problem and its solutions. Its formalism is based on the theory of controlled dynamical systems, with a strong focus on the optimal control of partially known Markov decision processes. Then, the core idea consists of capturing the essence of the problem when an agent learns through experience and interaction to reach a goal. This agent can sense the state of its environment to some extent and must be able to take action that affects the state. The agent also must have a goal or goals related to the state of the environment.\nMDPs are designed to incorporate three essential elements: sensation, action, and goal. Therefore, any approach suitable for solving such problems should be considered a potential method for Reinforcement Learning.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "02-introductionToRL/intro.html#exploration-exploration-dilemma-and-uncertainty",
    "href": "02-introductionToRL/intro.html#exploration-exploration-dilemma-and-uncertainty",
    "title": "Introduction",
    "section": "Exploration-exploration dilemma and uncertainty",
    "text": "Exploration-exploration dilemma and uncertainty\nTo obtain the best reward, the agent must prefer actions used in the past and perceived as effective to produce a reward. However, to discover such actions, the agent must try actions never used before. So, there is a delicate trade-off between exploiting and exploring. The agent has to exploit its knowledge to produce a reward but simultaneously has to explore to improve its reward in the future. Here, our dilemma is that neither exploration nor exploitation can be pursued exclusively without failing the task.\nAnother essential aspect of reinforcement learning is that it specifically deals with the entire process of a goal-directed agent interacting with an uncertain environment. This aspect differs from many approaches that only focus on subproblems rather than considering how they might contribute to the bigger picture. For example, many machine learning researchers have studied supervised Learning without specifying how such an ability would ultimately be helpful. Other researchers have developed planning theories with general goals without considering planning’s role in real-time decision-making or whether the predictive models necessary for planning are well suited. Although these approaches have produced valuable results, their focus on isolated subproblems leads to significant limitations.\nReinforcement learning takes the opposite approach, beginning with a fully interactive, goal-seeking agent. In reinforcement learning, the agent has explicit goals, can sense aspects of their environment, and can choose actions to influence its environment.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "02-introductionToRL/intro.html#examples",
    "href": "02-introductionToRL/intro.html#examples",
    "title": "Introduction",
    "section": "Examples",
    "text": "Examples\n\nA master chess player makes a move.\nAn adaptive controller adjusts parameters of a petroleum refinery’s operation in real time.\nA gazelle calf struggles to its feet minutes after being born.\nA mobile robot decides whether it should enter a new room in search of more trash to collect or start trying to find its way back to its battery recharging station.\nPhil prepares his breakfast",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "02-introductionToRL/intro.html#the-possible-4-elements-of-reinforcement-learning",
    "href": "02-introductionToRL/intro.html#the-possible-4-elements-of-reinforcement-learning",
    "title": "Introduction",
    "section": "The (possible) 4 elements of Reinforcement Learning",
    "text": "The (possible) 4 elements of Reinforcement Learning\nGiven an agent, we identify four main element in a reinforcement learning model:\n\na policy, a reward, a value function and (optionally) a model of the environment.\n\n\nPolicy\n\nA policy is as a set of actions that guide the agent to respond according to its perception of the environment. It’s like a set of instructions that tell the agent what to do when it encounters a certain situation. In general, policies may be stochastic, specifying probabilities for each action.\n\nReward\n\nThe reward signal thus defines what are the good and bad events for the agent. In a biological system, we might think of rewards as analogous to the experiences of pleasure or pain. They are the immediate and defining features of the problem faced by the agent. The reward signal is the primary basis for altering the policy; if an action selected by the policy is followed by low reward, then the policy may be changed to select some other action in that situation in the future. In general, reward signals may be stochastic functions of the state of the environment and the actions taken.\n\nValue function\n\nWhereas the reward signal indicates what is good in the immediate sense, a value function specifies what is good in the long run. In simple terms, the value of a state represents the total reward an agent can anticipate to receive in the future, beginning from that state. While rewards reflect the immediate appeal of environmental states, values signify the long-term appeal of states, considering the potential future states and the rewards they offer. For example, a state might consistently yield a low immediate reward but still have a high value because it is regularly followed by other states that yield high rewards. Alternatively, the opposite could also be true. Rewards can be compared to pleasure (when high) and pain (when low). At the same time, values represent a more precise and long-term assessment of how satisfied or dissatisfied we are with the state of our environment. In a sense, rewards are primary, whereas values, as predictions of rewards, are secondary. Without rewards, there could be no values, and the only purpose of estimating values is to achieve more rewards.\nAction choices are made based on value judgments. We seek actions that bring about states of highest value, not highest reward, because these actions obtain the greatest amount of reward for us over the long run. In fact, the most important component of almost all reinforcement learning algorithms we consider is a method for efficiently estimating values.\n\nEnvironment model\n\nThe environment model is something that mimics the behavior of the environment or, more generally, that allows inferences to be made about how the environment will behave. For example, given a state and action, the model might predict the resultant next state and next reward. Models are used for planning. This means making decisions by considering potential future situations before they occur. For our purposes, the environment can be represented as a dynamic system through an ordinary differential equation or a discrete finite difference equation.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "02-introductionToRL/intro.html#a-toy-rl-exmaple-tic-tac-toe",
    "href": "02-introductionToRL/intro.html#a-toy-rl-exmaple-tic-tac-toe",
    "title": "Introduction",
    "section": "A toy RL-exmaple: Tic-Tac-Toe",
    "text": "A toy RL-exmaple: Tic-Tac-Toe\nTo illustrate the general idea of reinforcement learning and contrast it with other ap- proaches, we next consider a single example in more detail.\nConsider the familiar child’s game of tic-tac-toe.\n\nAlthough the tic-tac-toe game is a simple problem, it cannot be satisfactorily solved using classical techniques.\nFor instance, the classical “minimax” solution from game theory is not applicable here because it assumes the opponent’s specific way of playing. A minimax player would never reach a game state from which it could lose. Even if, in reality, it always won from that state due to incorrect play by the opponent. The classical optimization methods for sequential decision problems, like dynamic programming, can find the best solution for any opponent. However, these methods need a detailed description of the opponent as input, including the probabilities of the opponent’s moves in each board state.\nAlternatively, this information can be estimated through experience, such as playing numerous games against the opponent. The best approach to this problem is to first learn a model of the opponent’s behavior with a certain level of confidence, and then use dynamic programming to calculate an optimal solution based on the approximate opponent model.\nSutton and Barto (see pp. 9-12 Sutton and Barto 2018) propose the following way to approach tic tac toe with Reinforcement Learning:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "02-introductionToRL/intro.html#setup",
    "href": "02-introductionToRL/intro.html#setup",
    "title": "Introduction",
    "section": "Setup:",
    "text": "Setup:\n\nFirst we would set up a table of numbers (or labels), one for each possible state of the game.\nEach number will be the latest estimate of the probability of our winning from that state.\nWe treat this estimate as the state’s value, and the whole table is the learned value function.\nState \\(A\\) has higher value than state \\(B\\), or is considered ‘better’ than state \\(B\\), if the current estimate of the probability of our winning from \\(A\\) is higher than it is from \\(B\\).\nIf we always play \\(Xs\\), then for all states with three \\(Xs\\) in a row the probability of winning is 1, because we have already won.\nSimilarly, for all states with three \\(Os\\) in a row, or that are filled up, the correct probability is 0–we cannot win from them.\nWe set the initial values of all the other states to \\(0.5\\), representing a guess that we have a 50% chance of winning.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "02-introductionToRL/intro.html#training",
    "href": "02-introductionToRL/intro.html#training",
    "title": "Introduction",
    "section": "Training:",
    "text": "Training:\nWe then play many games against the opponent.\nTo select our moves we examine the states that would result from each of our possible moves (one for each blank space on the board) and look up their current values in the table. Most of the time we move greedily,selecting the move that leads to the state with greatest value, that is, with the highest estimated probability of winning.\nOccasionally, however, we select randomly from among the other moves instead. These are called exploratory moves because they cause us to experience states that we might otherwise never see.\nA sequence of moves made and considered during a game can be diagrammed as the following figure:\n\n\n\n\n\n\nFigure 1: Figure taken from (Sutton and Barto 2018). A sequence of tic-tac-toe moves. Solid black lines represents moves taken during a play. Dashed lines represent plausible but not taken moves. The \\(*\\) symbol indicates the move currently estimated to be the best. Thus the move \\(e\\) denotes an exploratory move\n\n\n\n\n\n\n\n\nFigure 1: Figure taken from (Sutton and Barto 2018). A sequence of tic-tac-toe moves. Solid black lines represents moves taken during a play. Dashed lines represent plausible but not taken moves. The \\(*\\) symbol indicates the move currently estimated to be the best. Thus the move \\(e\\) denotes an exploratory move\n\n\n\nSutton, Richard S., and Andrew G. Barto. 2018. Reinforcement Learning: An Introduction. Second. Adaptive Computation and Machine Learning. MIT Press, Cambridge, MA.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "03-multiArmedBandit/multiarmed_bandits.html",
    "href": "03-multiArmedBandit/multiarmed_bandits.html",
    "title": "Multi-armed Bandits",
    "section": "",
    "text": "Multi-armed Bandits\nA very important feature distinguishing reinforcement learning from other types of learning is that it uses training information to evaluate the actions taken, rather than instruct by giving correct actions.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Multi-armed Bandits</span>"
    ]
  },
  {
    "objectID": "03-multiArmedBandit/multiarmed_bandits.html#action-value-methods",
    "href": "03-multiArmedBandit/multiarmed_bandits.html#action-value-methods",
    "title": "Multi-armed Bandits",
    "section": "Action-value Methods",
    "text": "Action-value Methods\nOne natural way to estimate the value of a given action is by averaging the rewards actually received. In mathematical symbols reads\n\\[\n  Q_t(a):=\n    \\dfrac{\n      \\sum_{i=1}^{t-1}\n        R_i \\cdot \\mathbb{1}_{A_{i} = a}\n    }{\\sum_{i=1}^{t-1} \\mathbb{1}_{A_i=a}} .\n\\tag{2.1}\\]\nNext we understand as greedy action as the action that results from \\[\n  A_t := \\underset{a}{\\mathrm{argmax}} \\ Q_t(a).\n\\tag{2.2}\\]\nGreedy action selection always exploits current knowledge to maximize immediate reward. It also only spends time sampling apparently superior actions. A simple alternative is to behave greedily but occasionally, with a small \\(\\epsilon\\)-probability, select randomly from all the actions with equal probability, regardless of the action-value estimates. We call methods using this near-greedy action selection rule \\(\\epsilon\\)-greedy methods.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Multi-armed Bandits</span>"
    ]
  },
  {
    "objectID": "03-multiArmedBandit/multiarmed_bandits.html#the-10-armed-testbed",
    "href": "03-multiArmedBandit/multiarmed_bandits.html#the-10-armed-testbed",
    "title": "Multi-armed Bandits",
    "section": "The 10-armed Testbed",
    "text": "The 10-armed Testbed\nTo evaluate the relative effectiveness of the greedy and \\(\\epsilon\\)-greedy action-value methods, we compared them numerically on a suite of test problems.\n\nSet up\n\n\n\n\n\n\nThe experiment runs as follows.\n\n\n\n\nConsider a \\(k\\)-bandit problem with \\(k=10\\)\nFor each bandit problem, the action values\n\n\\[\n  q_{*}(a) \\sim \\mathcal{N}(0,1)\n\\]\n\nThen when choosing an action \\(A_t\\) the corresponding reward \\(R_t\\) is sampling from a Gaussian distribution \\[\nR_t \\sim \\mathcal{N}(q_{*}(A_t), 1)  \n\\]\n\n\n\n\n\nCode\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\n\n# Randomly sample mean reward for each action\nmeans = np.random.normal(size=(10, ))\n\n# Generate sample data based on normal distribution\ndata = [np.random.normal(mean, 1.0, 2000) for mean in means]\n\n# Create violin plot\nplt.figure(figsize=(8, 6), dpi=150)\nplt.violinplot(\n  dataset=data,\n  showextrema=False,\n  showmeans=False,\n  points=2000\n)\n\n# Draw mean marks\nfor i, mean in enumerate(means):\n    idx = i + 1\n    plt.plot([idx - 0.3, idx + 0.3], [mean, mean],\n             c='black',\n             linewidth=1)\n    plt.text(idx + 0.2, mean - 0.2, \n             s=f\"$q_*({idx})$\",\n             fontsize=8)\n\n# Draw 0-value dashed line\nplt.plot(np.arange(0, 12), np.zeros(12), \n            c='gray', \n            linewidth=0.5,\n            linestyle=(5, (20, 10)))\nplt.tick_params(axis='both', labelsize=10)\nplt.xticks(np.arange(1, 11))\n\n# get rid of the frame\nfor i, spine in enumerate(plt.gca().spines.values()):\n    if i == 2: continue\n    spine.set_visible(False)\n    \n\n# Draw labels\nlabel_font = {\n    'fontsize': 12,\n    'fontweight': 'bold'\n}\n\nplt.xlabel('Action', fontdict=label_font)\nplt.ylabel('Reward distribution', fontdict=label_font)\nplt.margins(0)\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Multi-armed Bandits</span>"
    ]
  },
  {
    "objectID": "04-finiteMDPs/mdp.html",
    "href": "04-finiteMDPs/mdp.html",
    "title": "Finite Markov Decision Processes (MDPs)",
    "section": "",
    "text": "The Agent–Environment Interface",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Finite Markov Decision Processes (MDPs)</span>"
    ]
  },
  {
    "objectID": "04-finiteMDPs/mdp.html#the-agentenvironment-interface",
    "href": "04-finiteMDPs/mdp.html#the-agentenvironment-interface",
    "title": "Finite Markov Decision Processes (MDPs)",
    "section": "",
    "text": "Example 1 A mobile robot has the job of collecting empty soda cans in an office environment. It has sensors for detecting cans, and an arm and gripper that can pick them up and place them in an onboard bin; it runs on a rechargeable battery. The robot’s control system has components for interpreting sensory information, for navigating, and for controlling the arm and gripper. High-level decisions about how to search for cans are made by a reinforcement learning agent based on the current charge level of the battery. To make a simple example, we assume that only two charge levels can be distinguished, comprising a small state set \\(\\mathcal{S} = \\{\\texttt{high}, \\texttt{low} \\}\\). In each state, the agent can decide whether to\n\nactively search for a can for a certain period of time,\nremain stationary and wait for someone to bring it a can, or\nhead back to its home base to recharge its battery.\n\nWhen the energy level is high, recharging would always be foolis h, so we do not include it in the action set for this state. The action sets are then $ () = {, } $ and \\(\\mathcal{A}(\\texttt{low}) = \\{\\texttt{search}, \\texttt{wait}, \\texttt{recharge}\\}\\).\nThe rewards are zero most of the time, but become positive when the robot secures an empty can, or large and negative if the battery runs all the way down. The best way to find cans is to actively search for them, but this runs down the robot’s battery, whereas waiting does not. Whenever the robot is searching, the possibility exists that its battery will become depleted. In this case the robot must shut down and wait to be rescued (producing a low reward).\nIf the energy level is high, then a period of active search can always be completed without risk of depleting the battery. A period of searching that begins with a high energy level leaves the energy level high with probability \\(\\alpha\\) and reduces it to low with probability \\(1 - \\alpha\\). On the other hand, a period of searching undertaken when the energy level is low leaves it low with probability \\(\\beta\\) and depletes the battery with probability \\(1 - \\beta\\). In the latter case, the robot must be rescued, and the battery is then recharged back to high. Each can collected by the robot counts as a unit reward, whereas a reward of \\(-3\\) results whenever the robot has to be rescued. Let \\(r_{\\texttt{search}}\\) and \\(r_{\\texttt{wait}}\\), with \\(r_{\\texttt{search}} &gt; r_{\\texttt{wait}}\\), denote the expected numbers of cans the robot will collect (and hence the expected reward) while searching and while waiting respectively. Finally, suppose that no cans can be collected during a run home for recharging, and that no cans can be collected on a step in which the battery is depleted. This system is then a finite MDP, and we can write down the transition probabilities and the expected rewards, with dynamics as indicated in the table on the left:\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\nExercise 1 Give a table analogous to that in (p.53, Ex. 3.3, Sutton and Barto 2018), but for \\(p(s_0 , r |s, a)\\). It should have columns for \\(s\\), \\(a\\), \\(s_0\\) , \\(r\\), and \\(p(s_0 , r |s, a)\\), and a row for every 4-tuple for which \\(p(s_0 , r |s, a) &gt; 0\\).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Finite Markov Decision Processes (MDPs)</span>"
    ]
  },
  {
    "objectID": "04-finiteMDPs/mdp.html#goals-and-rewards",
    "href": "04-finiteMDPs/mdp.html#goals-and-rewards",
    "title": "Finite Markov Decision Processes (MDPs)",
    "section": "Goals and Rewards",
    "text": "Goals and Rewards",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Finite Markov Decision Processes (MDPs)</span>"
    ]
  },
  {
    "objectID": "04-finiteMDPs/mdp.html#returns-and-episodes",
    "href": "04-finiteMDPs/mdp.html#returns-and-episodes",
    "title": "Finite Markov Decision Processes (MDPs)",
    "section": "Returns and Episodes",
    "text": "Returns and Episodes",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Finite Markov Decision Processes (MDPs)</span>"
    ]
  },
  {
    "objectID": "04-finiteMDPs/mdp.html#unified-notation-for-episodic-and-continuing-tasks",
    "href": "04-finiteMDPs/mdp.html#unified-notation-for-episodic-and-continuing-tasks",
    "title": "Finite Markov Decision Processes (MDPs)",
    "section": "Unified Notation for Episodic and Continuing Tasks",
    "text": "Unified Notation for Episodic and Continuing Tasks",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Finite Markov Decision Processes (MDPs)</span>"
    ]
  },
  {
    "objectID": "04-finiteMDPs/mdp.html#policies-and-value-functions",
    "href": "04-finiteMDPs/mdp.html#policies-and-value-functions",
    "title": "Finite Markov Decision Processes (MDPs)",
    "section": "Policies and Value Functions",
    "text": "Policies and Value Functions",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Finite Markov Decision Processes (MDPs)</span>"
    ]
  },
  {
    "objectID": "04-finiteMDPs/mdp.html#optimal-policies-and-optimal-value-functions",
    "href": "04-finiteMDPs/mdp.html#optimal-policies-and-optimal-value-functions",
    "title": "Finite Markov Decision Processes (MDPs)",
    "section": "Optimal Policies and Optimal Value Functions",
    "text": "Optimal Policies and Optimal Value Functions",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Finite Markov Decision Processes (MDPs)</span>"
    ]
  },
  {
    "objectID": "04-finiteMDPs/mdp.html#optimality-and-approximation",
    "href": "04-finiteMDPs/mdp.html#optimality-and-approximation",
    "title": "Finite Markov Decision Processes (MDPs)",
    "section": "Optimality and Approximation",
    "text": "Optimality and Approximation",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Finite Markov Decision Processes (MDPs)</span>"
    ]
  },
  {
    "objectID": "04-finiteMDPs/mdp.html#summary",
    "href": "04-finiteMDPs/mdp.html#summary",
    "title": "Finite Markov Decision Processes (MDPs)",
    "section": "Summary",
    "text": "Summary\n\n\n\n\n\n\nSutton, Richard S., and Andrew G. Barto. 2018. Reinforcement Learning: An Introduction. Second. Adaptive Computation and Machine Learning. MIT Press, Cambridge, MA.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Finite Markov Decision Processes (MDPs)</span>"
    ]
  },
  {
    "objectID": "05-dynamicProgramming/dp_rl.html",
    "href": "05-dynamicProgramming/dp_rl.html",
    "title": "Dynamic Programming",
    "section": "",
    "text": "Policy Evaluation (Prediction)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dynamic Programming</span>"
    ]
  },
  {
    "objectID": "05-dynamicProgramming/dp_rl.html#policy-improvement",
    "href": "05-dynamicProgramming/dp_rl.html#policy-improvement",
    "title": "Dynamic Programming",
    "section": "Policy Improvement",
    "text": "Policy Improvement",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dynamic Programming</span>"
    ]
  },
  {
    "objectID": "05-dynamicProgramming/dp_rl.html#policy-iteration",
    "href": "05-dynamicProgramming/dp_rl.html#policy-iteration",
    "title": "Dynamic Programming",
    "section": "Policy Iteration",
    "text": "Policy Iteration",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dynamic Programming</span>"
    ]
  },
  {
    "objectID": "05-dynamicProgramming/dp_rl.html#value-iteration",
    "href": "05-dynamicProgramming/dp_rl.html#value-iteration",
    "title": "Dynamic Programming",
    "section": "Value Iteration",
    "text": "Value Iteration",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dynamic Programming</span>"
    ]
  },
  {
    "objectID": "05-dynamicProgramming/dp_rl.html#asynchronous-dynamic-programming",
    "href": "05-dynamicProgramming/dp_rl.html#asynchronous-dynamic-programming",
    "title": "Dynamic Programming",
    "section": "Asynchronous Dynamic Programming",
    "text": "Asynchronous Dynamic Programming",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dynamic Programming</span>"
    ]
  },
  {
    "objectID": "05-dynamicProgramming/dp_rl.html#generalized-policy-iteration",
    "href": "05-dynamicProgramming/dp_rl.html#generalized-policy-iteration",
    "title": "Dynamic Programming",
    "section": "Generalized Policy Iteration",
    "text": "Generalized Policy Iteration",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dynamic Programming</span>"
    ]
  },
  {
    "objectID": "05-dynamicProgramming/dp_rl.html#efficiency-of-dynamic-programming",
    "href": "05-dynamicProgramming/dp_rl.html#efficiency-of-dynamic-programming",
    "title": "Dynamic Programming",
    "section": "Efficiency of Dynamic Programming",
    "text": "Efficiency of Dynamic Programming",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dynamic Programming</span>"
    ]
  },
  {
    "objectID": "05-dynamicProgramming/dp_rl.html#summary",
    "href": "05-dynamicProgramming/dp_rl.html#summary",
    "title": "Dynamic Programming",
    "section": "Summary",
    "text": "Summary",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dynamic Programming</span>"
    ]
  },
  {
    "objectID": "06-applications/applications.html",
    "href": "06-applications/applications.html",
    "title": "Applications",
    "section": "",
    "text": "Recycling Robot",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Applications</span>"
    ]
  },
  {
    "objectID": "06-applications/applications.html#a-robot-with-randomly-moves-in-a-grid-world.",
    "href": "06-applications/applications.html#a-robot-with-randomly-moves-in-a-grid-world.",
    "title": "Applications",
    "section": "A robot with randomly moves in a grid world.",
    "text": "A robot with randomly moves in a grid world.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Applications</span>"
    ]
  },
  {
    "objectID": "07-Project/project_proposal.html",
    "href": "07-Project/project_proposal.html",
    "title": "Project proposal",
    "section": "",
    "text": "Formulation and reinforcement learning solution to a problem\nof a sequence of decisions.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Project proposal</span>"
    ]
  },
  {
    "objectID": "07-Project/project_proposal.html#death-line",
    "href": "07-Project/project_proposal.html#death-line",
    "title": "Project proposal",
    "section": "Death line",
    "text": "Death line",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Project proposal</span>"
    ]
  },
  {
    "objectID": "07-Project/project_proposal.html#subproducts",
    "href": "07-Project/project_proposal.html#subproducts",
    "title": "Project proposal",
    "section": "Subproducts",
    "text": "Subproducts\n\nStage 01: Quarto book with MDP formulation\n\nThe page must encloses the report according to the template rl_bookdown_prg.qmd\n\nIntroduction\nFormulation of the Mrakov decision process\nModel dynamics\nDescription and justification of the Cost (reward)\nJustification of the actions\n\nMust include\n\nFigures to illustrates the behavior of the regarding elements:\n\nPolicy\nReward\nValue function eventuated for a one state-action and transition.\nEnvironmental model\n\nReferences via bibtex.\nOutput compilation for HTML and PDF formats.\nThe compiled version has to be mounted ing GitHub or Quarto Pub\n\n\n\n\nStage 02: Python code Implementation\n\nOnly code whit out running errors wold be accepted\nCode must follows the style guide from PEP 08\nAll functions must include doc-strings\nExtras:\nPacking and Documentation extra 200 xps\n\n\n\nStage 03: Video Presentation\nA video mounted in you-tube of at most 20 min with results and insight of your project",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Project proposal</span>"
    ]
  },
  {
    "objectID": "07-Project/project_proposal.html#suggested-project-list",
    "href": "07-Project/project_proposal.html#suggested-project-list",
    "title": "Project proposal",
    "section": "Suggested project list:",
    "text": "Suggested project list:\n\nReinforcement learning simulation of the TIC-TAC-TOE Game with SARSA or Q-learning Algorithms Bilgin (2020)\nThe movement of a Recycling Robot Bilgin (2020)\nThe replacement of a bus engine (Rust 1987) from (see pd.pdf, p.130 Stachurski. 2024)\nOptimal Inventories (see dp.pdf, p. 147 Stachurski. 2024)\nMulti-Armed Bandits Bilgin (2020)\n\n\n\n\n\n\n\nBilgin, E. 2020. Mastering Reinforcement Learning with Python: Build Next-Generation, Self-Learning Models Using Reinforcement Learning Techniques and Best Practices. Packt Publishing. https://books.google.com.mx/books?id=s0MQEAAAQBAJ.\n\n\nRust, John. 1987. “Optimal Replacement of GMC Bus Engines: An Empirical Model of Harold Zurcher.” Econometrica 55 (5): 999. https://doi.org/10.2307/1911259.\n\n\nStachurski., John. 2024. “Dynamic Programming Volume 1.” GitHub Repository. https://github.com/QuantEcon/book-dp1-public; GitHub.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Project proposal</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Bertsekas, Dimitri P. 2005. Dynamic Programming and Optimal Control.\nVol. I. Third. Athena Scientific,\nBelmont, MA.\n\n\nBilgin, E. 2020. Mastering Reinforcement Learning with Python: Build\nNext-Generation, Self-Learning Models Using Reinforcement Learning\nTechniques and Best Practices. Packt Publishing. https://books.google.com.mx/books?id=s0MQEAAAQBAJ.\n\n\nBrandimarte, Paolo. 2013. Numerical Methods in Finance and\nEconomics: A MATLAB-Based Introduction. 2nd ed. Hoboken, New\nJersey: John Wiley & Sons.\n\n\nBrunton, Steven L., and J. Nathan Kutz. 2019. Data-Driven Science\nand Engineering. Cambridge University Press, Cambridge. https://doi.org/10.1017/9781108380690.\n\n\nRust, John. 1987. “Optimal Replacement of GMC\nBus Engines: An Empirical Model of Harold Zurcher.”\nEconometrica 55 (5): 999. https://doi.org/10.2307/1911259.\n\n\nStachurski., John. 2024. “Dynamic Programming Volume 1.”\nGitHub Repository. https://github.com/QuantEcon/book-dp1-public; GitHub.\n\n\nSutton, Richard S., and Andrew G. Barto. 2018. Reinforcement\nLearning: An Introduction. Second. Adaptive Computation and Machine\nLearning. MIT Press, Cambridge, MA.\n\n\nSzepesvári, Csaba. 2022. Algorithms for Reinforcement Learning.\nVol. 9. Synthesis Lectures on Artificial Intelligence and Machine\nLearning. Springer, Cham. https://doi.org/10.1007/978-3-031-01551-9.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "homeworks/home_works_list.html",
    "href": "homeworks/home_works_list.html",
    "title": "List of Home Works and due dates",
    "section": "",
    "text": "Homework 001 due date: september 20, 2024-12:00:00",
    "crumbs": [
      "List of Home Works and due dates"
    ]
  },
  {
    "objectID": "homeworks/home_works_list.html#homework-001-due-date-september-20-2024-120000",
    "href": "homeworks/home_works_list.html#homework-001-due-date-september-20-2024-120000",
    "title": "List of Home Works and due dates",
    "section": "",
    "text": "Exercise 1 Read (Sec 1.1, pp 1-2 Sutton and Barto 2018) and answer the following.\nExplain why Reinforcement Learning differs for supervised and unsupervised learning.\n\n\nExercise 2 See the first Steve Brunton’s youtube video about Reinforcement Learning. Then accordingly to its presentation explain what is the meaning of the following expression:\n\\[\n  V_{\\pi}(s) = \\mathbb{E}\n\\left(\n   \\sum_{t} \\gamma ^ {t} r_t | s_0 = s\n\\right).\n\\]\n\n\nExercise 3 Form (see Sutton and Barto 2018, sec. 1.7) obtain a time line pear year from 1950 to 2012.\nUse the following format see https://kim.quarto.pub/milestones–bar-timelines/\n\nCodelibrary(bibtex)\n## Activate the Core Packages\nbiblio &lt;- bibtex::read.bib(\"../references.bib\")\nlibrary(tidyverse) ## Brings in a core of useful functions\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nCodelibrary(gt)        ## Tables\n## Specific packages\nlibrary(milestones)\n## Initialize defaults\n## Initialize defaults\ncolumn &lt;- lolli_styles()\n\ndata &lt;- read_csv(col_names=TRUE, show_col_types=FALSE, file='rl_time_line.csv')\n\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat &lt;- vroom(...)\n  problems(dat)\n\nCode## Sort the table by date\ndata &lt;- data |&gt;\n  arrange(date)\n\n## Build a table\ngt(data) |&gt;\n  #cols_hide(columns = event) |&gt;\n  tab_style(cell_text(v_align = \"top\"),\n            locations = cells_body(columns = date)) |&gt;\n  tab_source_note(source_note = \"Source: Sutton and Barto (2018)\") \n\n\n\n\n\n\ndate\nevent\nReference\n\n\n\n1957\nThe term “optimal control” appears\nMR0090477 Bellman, Richard Dynamic programming. Princeton University Press, Princeton, NJ, 1957. xxv+342 pp.\n\n\n1957\nDefinition of the term MDPs\nMR0091859 Bellman, Richard A Markovian decision process.J. Math. Mech.6(1957), 679–684.\n\n\n1985\nApplication of MDPs\nMR1295629 White, D. J. Markov decision processes.John Wiley & Sons, Ltd., Chichester, 1993. xiv+224 pp. ISBN:0-471-93627-8\n\n\n1988\nApplications of MDPs\nMR1295629 White, D. J. Markov decision processes.John Wiley & Sons, Ltd., Chichester, 1993. xiv+224 pp. ISBN:0-471-93627-8\n\n\n1991\nPartial observable MDP\nMR1105166 Lovejoy, William S.A survey of algorithmic methods for partially observed Markov decision processes.Ann. Oper. Res.28(1991), no.1-4, 47–65.\n\n\n1993\nApplications of MDPs\nMR1200993 White, D. J.Markov decision processes: discounted expected reward or average expected reward?.J. Math. Anal. Appl.172(1993), no.2, 375–384.\n\n\n1996\nNumerical DP\nMR1416619 Rust, John Numerical dynamic programming in economics.Handbook of computational economics, Vol. I, 619–729. Handbooks in Econom., 13 North-Holland Publishing Co., Amsterdam, 1996 ISBN:0-444-89857-3\n\n\n\nSource: Sutton and Barto (2018)\n\n\n\n\n\n\n\nCode## Adjust some defaults\ncolumn$color &lt;- \"orange\"\ncolumn$size  &lt;- 15\ncolumn$source_info &lt;- \"Source: Sutton and Barto (2018)\"\n\n## Milestones timeline\nmilestones(datatable = data, styles = column)\n\n\n\n\n\n\n\n\n\nExercise 4 Consider the following consumption–saving problem with dynamics \\[\n  x_{k+1}\n  = (1+r)(x_k-a_k),\\qquad k=0,1,\\ldots,N-1,\n\\] and utility function\n\\[\n  \\beta^N(x_N)^{1-\\gamma}\n    + \\sum_{k=0}^{N-1}\\beta^k (a_k)^{1-\\gamma}.\n\\]\nShow that the value functions of the DP algorithm take the form \\[J_k(x)=A_k\\beta^kx^{1-\\gamma},\\] where \\(A_N=1\\) and for \\(k=N-1,\\ldots,0\\),\n\\[  A_k = [1 + ((1+r)\\beta A_{k+1})^{1/\\gamma} ]^\\gamma.  \\] Show also that the optimal policies are \\(h_k(x)=A_k^{-1/\\gamma} x\\). for \\(k=N-1,\\ldots,0\\).\n\n\nExercise 5 Consider now the infinite–horizon version of the above consumption–saving problem.\n\nWrite down the associated Bellman equation.\nArgue why a solution to the Bellman equation should be of the form \\[v(x)=cx^{1-\\gamma},\\] where \\(c\\) is constant. Find the constant \\(c\\) and the stationary optimal policy 1.\n\n\n\nExercise 6 Let \\(\\{\\xi_k\\}\\) be a sequence of iid random variables such that \\(E[\\xi]=0\\) and \\(E[\\xi^2]=d\\). Consider the dynamics \\[\n  x_{k+1} = x_k + a_k + \\xi_k, \\qquad\n  k= 0,1,2,\\ldots,\n\\] and the discounted cost \\[\n  E \\sum \\beta^k(a_k^2+x_k^2).\n\\]\n\nWrite down the associated Bellman equation.\nConjecture that the solution to the Bellman equation takes the form \\(v(x)=ax^2+b\\), where \\(a\\) and \\(b\\) are constant.\nDetermine the constants \\(a\\) and \\(b\\).\nConjecture that the solution to the Bellman equation takes the form \\(v(x)=ax^2+b\\), where \\(a\\) and \\(b\\) are constant. Determine the constants \\(a\\) and \\(b\\).\n\n\n\n\n\n\n\n\nSutton, Richard S., and Andrew G. Barto. 2018. Reinforcement Learning: An Introduction. Second. Adaptive Computation and Machine Learning. MIT Press, Cambridge, MA.",
    "crumbs": [
      "List of Home Works and due dates"
    ]
  },
  {
    "objectID": "homeworks/home_works_list.html#footnotes",
    "href": "homeworks/home_works_list.html#footnotes",
    "title": "List of Home Works and due dates",
    "section": "",
    "text": "Hint: Insert \\(v(x)=cx^{1-\\gamma}\\) into the Bellman equation and solve the minimization problem.↩︎",
    "crumbs": [
      "List of Home Works and due dates"
    ]
  }
]